\subsubsection{Package Database}
\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{VisualParadigm/diagramma_prg_database.png}
  \caption{Diagramma delle classi del package Database}
  \label{fig:package_database}
\end{figure}

Il \texttt{package Database} contiene le classi che gestiscono la connesione
alla base dati. In particolare si è deciso di utilizzare un approccio basato
su Data Access Object, così da incapsulare la logica di accesso al database
senza che i livelli superiori se debbano occupare.
Le classi qui definite sono:
\begin{description}
\item[DBManager], è la classe che si occupa di creare la connesione al database, tramite protocollo ODBC
\item[UserDAO], è la classe che si occupa di gestire l'accesso alla tabella Utenti nella base di dati
\item[ConferenceDAO], è la classe che si occupa di gestire l'accesso alla tabella Conferenze nella base di dati
\item[ArticleDAO], è la classe che si occupa di gestire l'accesso alla tabella Articoli nella base di dati
\item[ReviewDAO], è la classe che si occupa di gestire i reviewers nella base di dati
\end{description}

\paragraph{DBManager}
La classe DBManager presenta due metodi:
\begin{description}
\item[Costruttore] Costruttore che inizializza la connesione tra il sistema e la base di dati tramite ODBC
\item[getConnection] Getter per la connesione, utilizzato dalle altre classi
  per poter comunicare con la base di dati, senza avere la responsabilità di
  dover gestire la connesione stessa
\end{description}

\paragraph{UserDAO}
La classe UserDAO presenta i seguenti metodi:
\begin{itemize}
\item getUserRoleByID
\item getUserByID
\item isUserPresentByID
\item isUserPresentByEmail
\item getUserIdByEmail
\item getAllAuthors
\item saveUser
\end{itemize}

\paragraph{ConferenceDAO}
La classe ConferenceDAO presenta i seguenti metodi:
\begin{itemize}
\item getAllConferences
\item getArticlesByConference
\item saveConference
\end{itemize}

\paragraph{ArticleDAO}
La classe ArticleDAO presenta i seguenti metodi:
\begin{itemize}
\item getArticleByAuthor
\item updateArticleStatus
\item getArticleByID
\item saveArticle
\end{itemize}

\paragraph{ReviewDAO}
La classe ReviewDAO presenta i seguenti metodi:
\begin{itemize}
\item assignReviewer
\item getReviewers
\item hasConflictOfInterest
\end{itemize}

\paragraph{Progettazione Database}
% DONE: Riscrivere modello ER e relativa progettazione fisica
Nella figura \ref{fig:modello_er} è presentato il modello ER su cui è basato il
database
\begin{figure}[!ht]
  \centering
  \includegraphics[width=\linewidth]{VisualParadigm/er_finale.png}
  \caption{Modello ER del database}
  \label{fig:modello_er}
\end{figure}

Di seguito la progettazione fisica del database:
\begin{minted}[breaklines]{sql}
    DROP DATABASE IF EXISTS testDB;
CREATE DATABASE testDB;

USE testDB;

-- Tabelle
---- Utenti
CREATE TABLE Utenti (
       ID varchar(36) primary key,
       NOME varchar(100) not null,
       COGNOME varchar(100) not null,
       AFFILIAZIONE varchar(100) not null,
       EMAIL varchar(200) not null,
       PASSWORD varchar(130) not null,
       RUOLO varchar(13) not null,
       constraint CHECK_RUOLO check (RUOLO = 'autore' or RUOLO = 'organizzatore')
);

---- Articoli
CREATE TABLE Articoli (
       ID varchar(36) primary key,
       TITOLO varchar(140) not null,
       ABSTRACT varchar(250) not null,
       STATO varchar(11) not null,
       constraint CHECK_STATO check (STATO = 'sottomesso' or STATO = 'in revisione')
);

---- Autori (Tabella di supporto per relazionare Utenti e Articoli)
CREATE TABLE Autori (
       ID_UTENTE VARCHAR(36),
       ID_ARTICOLO VARCHAR(36),
       constraint PK_AUTORI primary key(ID_UTENTE, ID_ARTICOLO),
       constraint FK_AUTORI_UTENTI foreign key(ID_UTENTE) references Utenti(ID),
       constraint FK_AUTORI_ARTICOLI foreign key(ID_ARTICOLO) references Articoli(ID)
);

---- Conferenze
CREATE TABLE Conferenze (
       ID varchar(36) primary key,
       TITOLO varchar(140),
       DESCRIZIONE varchar(250),
       SCADENZA date not null,
       ORGANIZZATORE varchar(36),
       constraint FK_CONFERENZE_UTENTI foreign key(ORGANIZZATORE) references Utenti(ID)
);

---- Sottomissioni (Tabella di supporto per relazionare Utenti, Articolo e Conferenza)
CREATE TABLE Sottomissioni (
       ID_ARTICOLO varchar(36),
       ID_CONFERENZA varchar(36),
       constraint PK_SOTTOMISSIONI primary key(ID_ARTICOLO, ID_CONFERENZA),
       constraint FK_SOTTOMISSIONI_ARTICOLI foreign key(ID_ARTICOLO) references Articoli(ID),
       constraint FK_SOTTOMISSIONI_CONFERENZE foreign key(ID_CONFERENZA) references Conferenze(ID)
);

---- Revisione (Tabella che implementa le revisioni e i revisori)
CREATE TABLE Revisioni (
       ID varchar(36),
       ID_REVISORE varchar(36),
       ID_ARTICOLO varchar(36),
       PUNTEGGIO integer,
       ESITO varchar(9),
       constraint FK_REVISIONI_UTENTI foreign key(ID_REVISORE) references Utenti(ID),
       constraint FK_REVISIONI_ARTICOLI foreign key(ID_ARTICOLO) references Articoli(ID),
       constraint CHEK_ESITO check (ESITO = 'accettato' or ESITO = 'rifiutato')
);
  \end{minted}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
